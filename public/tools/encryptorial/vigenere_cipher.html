<section id="tool_section">
    <h1>維吉尼亞密碼工具</h1>

    <label for="plaintextInput">輸入文字：</label>
    <textarea id="plaintextInput" rows="3" placeholder="請輸入明文"></textarea>

    <label for="keyInput">密鑰 (只輸入英文字母)：</label>
    <input type="text" id="keyInput" placeholder="如：LEMON" maxlength="20" />

    <div id="buttonGroup">
        <button onclick="vigenereEncrypt()">加密</button>
        <button onclick="vigenereDecrypt()">解密</button>
    </div>

    <label for="outputText">結果：</label>
    <textarea id="outputText" rows="3" readonly></textarea>

    <details>
        <summary>動畫設定</summary>
        <label>
            <input type="checkbox" id="vigenereEnableAnimation" checked />
            啟用動畫效果
        </label>
        <div id="animation-speed-inline">
            <label for="vigenereAnimationSpeed">動畫速度</label>
            <span title="快速">🐇</span>
            <input type="range" id="vigenereAnimationSpeed" min="10" max="500" value="100" />
            <span title="慢速">🐢</span>
        </div>
    </details>
    <!-- 清晰展示狀態的字母格子（可延伸使用） -->
    <div id="vigenere_letter_grid">
        <div class="letter-row uppercase-row"></div>
        <div class="letter-row lowercase-row"></div>
    </div>
</section>
<section id="explanation">
    <h2>維吉尼亞密碼介紹</h2>
    <p>維吉尼亞密碼是一種利用字母表各字元輪替位移的古老加密技術，依照密鑰每個字元決定每個明文字元的偏移量。</p>
    <p>密鑰重複用於明文，產生不同的加密結果，增加破解難度。</p>
</section>
<script>
    // 修正負數位移無限迴圈問題，對shift做mod 26
    function modShift(shift) {
        return ((shift % 26) + 26) % 26;
    }

    // 動畫控制變數
    let vigenereAnimationRunning = false;
    let vigenereAnimationCancelToken = 0;

    async function animateVigenereShift(text, key, isEncrypt = true) {
        const outputElem = document.getElementById('outputText');
        const enableAnimation = document.getElementById('vigenereEnableAnimation').checked;
        const speed = parseInt(document.getElementById('vigenereAnimationSpeed').value, 10);

        const letterGrid = document.getElementById('vigenere_letter_grid');
        if (letterGrid) letterGrid.style.display = enableAnimation ? 'flex' : 'none';

        vigenereAnimationCancelToken++;
        const currentToken = vigenereAnimationCancelToken;
        vigenereAnimationRunning = true;

        // 產生字母格子（只第一次產生）
        if (enableAnimation && letterGrid && letterGrid.children[0].children.length === 0) {
            createVigenereLetterGrid();
        }

        // 將密鑰轉為字母偏移數字(A=0~Z=25)
        const keyShifts = [];
        for (const kc of key.toUpperCase()) {
            if (kc >= 'A' && kc <= 'Z') {
                keyShifts.push(kc.charCodeAt(0) - 65);
            }
        }
        if (keyShifts.length === 0) {
            alert('密鑰須包含至少一個英文字母！');
            vigenereAnimationRunning = false;
            return;
        }

        let finalResult = '';
        for (let i = 0; i < text.length; i++) {
            const ch = text[i];
            if (ch.match(/[a-zA-Z]/)) {
                const code = ch.charCodeAt(0);
                const isUpper = (code >= 65 && code <= 90);
                const base = isUpper ? 65 : 97;

                const shift = keyShifts[i % keyShifts.length];
                const normalizedShift = isEncrypt ? shift : (26 - shift);

                const newCharCode = ((code - base + normalizedShift) % 26) + base;
                finalResult += String.fromCharCode(newCharCode);
            } else {
                finalResult += ch;
            }
        }

        // 不啟用動畫直接顯示結果
        if (!enableAnimation) {
            outputElem.value = finalResult;
            if (letterGrid) letterGrid.style.display = 'none';
            return;
        }

        // 動畫啟動
        outputElem.value = '';
        const wait = ms => new Promise(res => setTimeout(res, ms));
        let accumulated = '';
        let currentDisplay = Array(text.length).fill(' ');
        

        for (let i = 0; i < text.length; i++) {
            if (currentToken !== vigenereAnimationCancelToken) {
                vigenereAnimationRunning = false;
                return;
            }
            
            const ch = text[i];
            if (ch.match(/[a-zA-Z]/)) {
                const code = ch.charCodeAt(0);
                const isUpper = (code >= 65 && code <= 90);
                const base = isUpper ? 65 : 97;
                const shift = keyShifts[i % keyShifts.length];
                const normalizedShift = isEncrypt ? shift : (26 - shift);
                const startCode = code;
                const endCode = ((code - base + normalizedShift) % 26) + base;
                
                const originalChar = ch;                      // 原字元
                const finalChar = String.fromCharCode(endCode);    // 最終結果字元
                let currentCode = startCode;

                while (currentCode !== endCode) {
                    if (currentToken !== vigenereAnimationCancelToken) {
                        vigenereAnimationRunning = false;
                        return;
                    }
                    const currentChar = String.fromCharCode(currentCode); // 目前動畫字元（滾動中）

                    // 更新結果輸出
                    outputElem.value = accumulated + currentChar;

                    // 更新目前顯示字串（可擴展成字母格子顯示）
                    currentDisplay[i] = currentChar;
                    
                    // 動態更新字母格子高亮（如你後續想加）
                    
                    await wait(speed);

                    currentCode++;
                    if ((base === 65 && currentCode > 90) || (base === 97 && currentCode > 122)) {
                        currentCode = base;
                    }
                    updateLetterGridHighlight(originalChar, currentChar, finalChar);

                }
                updateLetterGridHighlight(originalChar, finalChar, finalChar);


                // 動畫結束：加上最後正確字元並更新顯示
                accumulated += String.fromCharCode(endCode);
                outputElem.value = accumulated;
                currentDisplay[i] = String.fromCharCode(endCode);

            } else {
                accumulated += ch;
                outputElem.value = accumulated;
                currentDisplay[i] = ch;
            }
            await wait(speed);
        }
        
        vigenereAnimationRunning = false;
    }

    // 產生字母格子（大寫、小寫列）
    function createVigenereLetterGrid() {
        const upperRow = document.querySelector('#vigenere_letter_grid .uppercase-row');
        const lowerRow = document.querySelector('#vigenere_letter_grid .lowercase-row');

        if (!upperRow || !lowerRow) return;

        upperRow.innerHTML = '';
        lowerRow.innerHTML = '';

        for (let i = 65; i <= 90; i++) {
            const span = document.createElement('span');
            span.classList.add('letter-cell');
            span.textContent = String.fromCharCode(i);
            upperRow.appendChild(span);
        }
        for (let i = 97; i <= 122; i++) {
            const span = document.createElement('span');
            span.classList.add('letter-cell');
            span.textContent = String.fromCharCode(i);
            lowerRow.appendChild(span);
        }
    }

    // 維吉尼亞加密觸發
    function vigenereEncrypt() {
        const plaintext = document.getElementById('plaintextInput').value;
        const key = document.getElementById('keyInput').value;
        if (!key.match(/^[a-zA-Z]+$/)) {
            alert('密鑰只能包含英文字母 A-Z');
            return;
        }
        animateVigenereShift(plaintext, key, true);
    }

    // 維吉尼亞解密觸發
    function vigenereDecrypt() {
        const ciphertext = document.getElementById('plaintextInput').value;
        const key = document.getElementById('keyInput').value;
        if (!key.match(/^[a-zA-Z]+$/)) {
            alert('密鑰只能包含英文字母 A-Z');
            return;
        }
        animateVigenereShift(ciphertext, key, false);
    }

    // 動畫勾選開關事件，可擴展使用
    function toggleVigenereAnimation() {
        const enableAnimation = document.getElementById('vigenereEnableAnimation').checked;
        const letterGrid = document.getElementById('vigenere_letter_grid');
        if (letterGrid) letterGrid.style.display = enableAnimation ? 'flex' : 'none';
    }

    function updateLetterGridHighlight(originalChar, currentChar, finalChar) {
        // 先清除現有狀態顏色
        document.querySelectorAll('#vigenere_letter_grid .letter-cell').forEach(cell => {
            cell.classList.remove('active-original', 'active-current', 'active-final');
        });

        // 依序為三個字元上色（若字元存在且為字母才標示）

        // 原字元標示
        if (originalChar) {
            if (originalChar >= 'A' && originalChar <= 'Z') {
                const upperCells = document.querySelectorAll('#vigenere_letter_grid .uppercase-row .letter-cell');
                upperCells[originalChar.charCodeAt(0) - 65]?.classList.add('active-original');
            } else if (originalChar >= 'a' && originalChar <= 'z') {
                const lowerCells = document.querySelectorAll('#vigenere_letter_grid .lowercase-row .letter-cell');
                lowerCells[originalChar.charCodeAt(0) - 97]?.classList.add('active-original');
            }
        }

        // 目前字元標示
        if (currentChar) {
            if (currentChar >= 'A' && currentChar <= 'Z') {
                const upperCells = document.querySelectorAll('#vigenere_letter_grid .uppercase-row .letter-cell');
                upperCells[currentChar.charCodeAt(0) - 65]?.classList.add('active-current');
            } else if (currentChar >= 'a' && currentChar <= 'z') {
                const lowerCells = document.querySelectorAll('#vigenere_letter_grid .lowercase-row .letter-cell');
                lowerCells[currentChar.charCodeAt(0) - 97]?.classList.add('active-current');
            }
        }

        // 結果字元標示
        if (finalChar) {
            if (finalChar >= 'A' && finalChar <= 'Z') {
                const upperCells = document.querySelectorAll('#vigenere_letter_grid .uppercase-row .letter-cell');
                upperCells[finalChar.charCodeAt(0) - 65]?.classList.add('active-final');
            } else if (finalChar >= 'a' && finalChar <= 'z') {
                const lowerCells = document.querySelectorAll('#vigenere_letter_grid .lowercase-row .letter-cell');
                lowerCells[finalChar.charCodeAt(0) - 97]?.classList.add('active-final');
            }
        }

        // 其他字母不做任何顏色更動，維持原始樣式
    }


</script>
<style>
    /* 工具區背景統一 */
    #tool_section {
        background-color: #c6f2ffd2;
        padding: 15px;
        border-radius: 5px;
        margin-bottom: 20px;
        display: flex;
        flex-direction: column;
        /* 讓區塊上下排列 */
        gap: 20px;
    }

    /* 輸入框和結果框 */
    textarea,
    input[type="text"] {
        width: 100%;
        font-size: 1rem;
        padding: 8px;
        border-radius: 5px;
        /* 與凱薩密碼統一 */
        border: 1px solid #b0c4de;
        resize: vertical;
        box-sizing: border-box;
        transition: border-color 0.3s ease;
        color: #222;
    }

    textarea:focus,
    input[type="text"]:focus {
        border-color: #3ca7d8;
        /* 凱薩藍 */
        outline: none;
        box-shadow: 0 0 8px #7ec4ff88;
    }

    /* 按鈕置中與間距 */
    #buttonGroup {
        margin-top: 10px;
        display: flex;
        gap: 10px;
    }

    /* 按鈕 */
    #buttonGroup button {
        flex: 1;
        padding: 10px 15px;
        font-size: 1rem;
        background-color: #3ca7d8;
        /* 按鈕藍 */
        color: white;
        border: none;
        border-radius: 5px;
        /* 與凱薩一致 */
        cursor: pointer;
        transition: background-color 0.25s ease;
    }

    #buttonGroup button:hover {
        background-color: #2a7bb7;
    }

    /* 折疊面板 */
    details {
        border: 1px solid #b0c4de;
        border-radius: 5px;
        padding: 10px 15px;
        background-color: #e6f0ff;
        color: #004080;
    }

    summary {
        font-weight: bold;
        cursor: pointer;

    }

    /* 動畫速度區 */
    #animation-speed-inline {
        display: flex;
        align-items: center;
        gap: 8px;
        width: fit-content;
    }

    #animation-speed-inline span {
        font-size: 20px;
        filter: grayscale(100%) brightness(0) saturate(100%);

    }

    /* 字母格子 */
    #vigenere_letter_grid {
        font-family: monospace;
        display: flex;
        flex-direction: column;
        gap: 8px;

        justify-content: center;
        align-items: center;
    }

    .letter-row {
        display: flex;
        gap: 4px;
        justify-content: center;
    }

    .letter-cell {
        width: 22px;
        height: 26px;
        border: 1px solid #ccc;
        border-radius: 5px;
        line-height: 26px;
        text-align: center;
        transition: background-color 0.3s ease;
        font-weight: 600;
        color: #003366;
    }

    /* 色彩配合凱薩密碼 */
    .letter-cell.active-original {
        background-color: #ffa67d;
        color: #3b1f00;
    }

    .letter-cell.active-current {
        background-color: #f7d87a;
        color: #4a3d00;
    }

    .letter-cell.active-final {
        background-color: #a0f7a4;
        color: #004d09;
    }

    /* 說明區 */
    section#explanation {
        background-color: #e6f0ff;
        padding: 15px;
        border-radius: 5px;
    }

    /* 響應式調整 */
    @media (max-width: 480px) {
        .letter-cell {
            width: 18px;
            height: 20px;
            font-size: 0.9rem;
        }
    }
</style>